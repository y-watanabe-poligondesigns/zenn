---
title: "ヘッドレスCMSを採用するときのフロントエンド技術を整理してみる"
emoji: "📝"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["headlesscms"]
published: true
---

## はじめに
本記事はフロントエンドエンジニア向けの記事です。
ヘッドレスCMSを採用した際に取り得る選択肢をまとめたものです。
microCMSなどのヘッドレスCMSを導入する際に、技術選定の一助になれば幸いです。

Webサイトの構築を前提とし、「お知らせを顧客側で更新できるようにしたい！」などのちょっとしたリクエストに答えるためのものです。

本記事ではSPA（CSR）・SSGという単語を利用します。
以下図解記事を参考にいたしました。

https://zenn.dev/bitarts/articles/37260ddb28ae5d


## パターン1：SPA（CSR）
VueやReactを利用してシングルアプリケーションとして描画する方法です。
クライアント側のみで完結できる（サーバーやインフラの考慮が必要ない）ので実装難易度が低いことが特徴です。

WebサイトにアクセスしWebサーバーにHTMLをリクエストした際は、空のHTMLが返ってきます。
そこからCMSへコンテンツの情報を取得しに行くため、描画速度は静的サイトに比べ時間がかかります。SEOの面も同様に、クローラーがまずはじめに空のHTMLにアクセスするため、正確にWebサイトのコンテンツを評価できない場合があります。


## パターン1 + α：プリレンダリングSPA
SPAの派生として、プリレンダリングSPAという手法があります。
予めコンテンツの一部をHTML化しておくことで、パターン1のSEO対策の面をカバーする案です。
以下の流れでCMSに登録されたコンテンツを描画します。

1）予めコンテンツの一部分を記載したHTMLを用意する
2）WebサイトにアクセスしWebサーバーにリクエストした際には、（1）のHTMLが返却される
3）CMSへコンテンツを取得し、最新情報に上書きする


## パターン2：SSG（Nuxt or Next）
SSG対応のフレームワークを利用するパターンです。
フレームワークの知識・CI/CDの知識も必要になるため実装難易度は高いです。
ユーザーがWebサイトにアクセスした際に、既にCMSの最新情報で生成されたHTMLを返却するため、描画速度も速くSEO対策も効果的に行うことができます。

AWSの場合はCloudfront + S3 + CodePipelineまたはAWS Amplifyで実現します。

以下の流れでCMSに登録されたコンテンツを描画します。
1）CMSのコンテンツを更新する
2）サーバーがWebhook等で変更を検知し、変更内容を取得・HTMLを生成する
3）ユーザーがアクセスすると（2）で生成されたHTMLが返却される


## パターン3 ：SSR
ユーザーがページに遷移した際にサーバー側でHTMLを生成して返却するパターンです。
PHPやRubyなどのサーバー側の言語を利用する、またはVue等のSSR対応フレームワークを利用します。

サーバー側でHTMLを生成するため、クローラーも正しくページの内容を理解することができます。
ユーザーがページ遷移してからサーバー側で最新コンテンツを取得して描画するため、描画までの時間が必要です。


## まとめ


|#|実装難易度|描画速度|SEO|
| ---- | ---- | ---- | ---- |
|SPA|★☆☆<br>クライアント側のみで完結|△<br>ユーザーがページに遷移したあとにコンテンツを取得|△|
|プリレンダリングSPA|★☆☆|△|〇|
|SSG|★★☆<br>CI/CDの知識・フレームワークの知識が必要|◎<br>予め最新コンテンツのHTMLを生成している|◎|
|SSR|★☆☆|△<br>ユーザーがページに遷移した後にコンテンツを取得|◎<br>サーバー側でHTMLを生成するため、クローラもページ内容の理解ができる|


サービスがtoC向けであれば描画速度・EO対策の取れた案を採用する必要があります。
加えて、期間や担当メンバーの得意な技術に合わせて選定していければと思います！
